import com.google.common.base.Joiner;
import com.hazelcast.config.Config;
import com.hazelcast.config.GroupConfig;
import com.hazelcast.config.MemberGroupConfig;
import com.hazelcast.config.NetworkConfig;
import com.hazelcast.config.PartitionGroupConfig;
import com.hazelcast.config.PartitionGroupConfig.MemberGroupType;
import com.hazelcast.config.SerializerConfig;
import com.hazelcast.nio.serialization.StreamSerializer;
import sgcib.ged.bcs.core.business.ProductMultipartDataSerializer;
import sgcib.ged.bcs.core.business.TradeMultipartDataSerializer;
import sgcib.ged.bcs.distributedcache.model.ProductMultipartData;
import sgcib.ged.bcs.distributedcache.model.TradeMultipartData;
import sgcib.ged.bcs.log.Logger;
import sgcib.ged.bcs.log.LoggerFactory;
import sgcib.ged.bcs.misc.PropertiesEx;
import sgcib.ged.bcs.string.StringUtils;

import javax.annotation.Nonnull;
import java.util.Collection;
import java.util.Set;

import static sgcib.ged.bcs.hazelcast.node.configuration.ClusterTopologyProperties.HAZELCAST_GROUP_NAME;
import static sgcib.ged.bcs.hazelcast.node.configuration.ClusterTopologyProperties.HAZELCAST_GROUP_PASSWORD;
import static sgcib.ged.bcs.hazelcast.node.configuration.ClusterTopologyProperties.HAZELCAST_JMX;
import static sgcib.ged.bcs.hazelcast.node.configuration.ClusterTopologyProperties.HAZELCAST_JMX_DETAILED;
import static sgcib.ged.bcs.hazelcast.node.configuration.ClusterTopologyProperties.HAZELCAST_LOGGING_TYPE;
import static sgcib.ged.bcs.hazelcast.node.configuration.ClusterTopologyProperties.HAZELCAST_MEMCACHE_ENABLED;
import static sgcib.ged.bcs.hazelcast.node.configuration.ClusterTopologyProperties
        .HAZELCAST_NODE_CONNECTION_TIMEOUT_SECONDS;
import static sgcib.ged.bcs.hazelcast.node.configuration.ClusterTopologyProperties.HAZELCAST_NODE_MEMBERS;
import static sgcib.ged.bcs.hazelcast.node.configuration.ClusterTopologyProperties.HAZELCAST_NODE_NAME;
import static sgcib.ged.bcs.hazelcast.node.configuration.ClusterTopologyProperties.HAZELCAST_NODE_PORT;
import static sgcib.ged.bcs.hazelcast.node.configuration.ClusterTopologyProperties.HAZELCAST_NODE_PORT_AUTO_INCREMENT;

public class ClusterTopologyImpl implements ClusterTopology {

    private static final Logger logger = LoggerFactory.getLogger(ClusterTopologyImpl.class);

    private final PropertiesEx prop;

    private final String version;

    public ClusterTopologyImpl(@Nonnull PropertiesEx properties, @Nonnull String version) {
        this.prop = properties;
        this.version = version;
    }

    private static <T> SerializerConfig create(StreamSerializer<T> serializer, Class<T> clazz) {
        return new SerializerConfig().setImplementation(serializer).setTypeClass(clazz);
    }

    @Override
    public CacheNode createCacheNode() {
        return new CacheNodeImpl(createMemberConfig(), prop, version);
    }

    private Config createMemberConfig() {

        String hzNodeName = prop.get(HAZELCAST_NODE_NAME);
        String hzName = StringUtils.isBlank(hzNodeName) ? prop.get("hazelcast.group.name") : hzNodeName;
        String name = String.format("bcs-%s", hzName);

        Config cfg = new Config();
        cfg.setInstanceName(name);

        //----------------------
        //-- Network config
        //----------------------
        NetworkConfig networkConfig = cfg.getNetworkConfig();
        // ports
        networkConfig.setPort(Integer.parseInt(prop.get(HAZELCAST_NODE_PORT)));
        // don't choose a different port if the specified one is taken
        networkConfig.setPortAutoIncrement(prop.getBoolean(HAZELCAST_NODE_PORT_AUTO_INCREMENT));
        networkConfig.setReuseAddress(true);
        // disable auto-detect nodes on same sub-network
        networkConfig.getJoin().getMulticastConfig().setEnabled(false);
        // explicitly specify cluster members
        networkConfig.getJoin().getTcpIpConfig().setEnabled(true);
        networkConfig.getJoin().getTcpIpConfig().setMembers(prop.getList(HAZELCAST_NODE_MEMBERS));
        // timeout for connecting to all cluster members
        networkConfig.getJoin().getTcpIpConfig()
                .setConnectionTimeoutSeconds(prop.getInt(HAZELCAST_NODE_CONNECTION_TIMEOUT_SECONDS));

        //----------------------
        //-- Partition Groups
        //----------------------
        // Partition groups ensure that backup copies are not stored on the same machine
        // and in same data center than primary copies.

        Collection<Set<String>> groups = CacheNodeConfigUtil.getPartitionGroups(prop);
        if (groups.size() == 1) {
            logger.warn("Ignoring partition groups, because only one group is configured.");
            PartitionGroupConfig partitionGroupConfig = cfg.getPartitionGroupConfig();
            partitionGroupConfig.setEnabled(false);
        } else {
            logger.info("Initializing partition groups...");
            PartitionGroupConfig partitionGroupConfig = cfg.getPartitionGroupConfig();
            partitionGroupConfig.setEnabled(true);
            partitionGroupConfig.setGroupType(MemberGroupType.CUSTOM);

            int partitionGroupId = 1;
            for (Set<String> groupMembers : groups) {
                logger.info("Partition group %d: %s",
                        partitionGroupId++, Joiner.on(",").join(groupMembers));

                MemberGroupConfig groupConfig = new MemberGroupConfig();
                groupConfig.setInterfaces(groupMembers);
                partitionGroupConfig.addMemberGroupConfig(groupConfig);
            }
        }

        //----------------------
        //-- Group config
        //----------------------
        cfg.setGroupConfig(
                new GroupConfig(prop.get(HAZELCAST_GROUP_NAME), prop.get(HAZELCAST_GROUP_PASSWORD)));

        //----------------------
        //-- Serialization config
        //----------------------
        //!\\ Must be configured on both server and client sides
        cfg.getSerializationConfig()
                .addSerializerConfig(create(new ProductMultipartDataSerializer(), ProductMultipartData.class))
                .addSerializerConfig(create(new TradeMultipartDataSerializer(), TradeMultipartData.class));

        //----------------------
        //-- Advanced config
        //----------------------
        // logging framework
        cfg.setProperty("hazelcast.logging.type", prop.get(HAZELCAST_LOGGING_TYPE));
        cfg.setProperty("hazelcast.memcache.enabled", prop.get(HAZELCAST_MEMCACHE_ENABLED));

        // jmx
        cfg.setProperty("hazelcast.jmx", prop.get(HAZELCAST_JMX));
        cfg.setProperty("hazelcast.jmx.detailed", prop.get(HAZELCAST_JMX_DETAILED));

        return cfg;
    }
}
=============

public class HazelcastNode {

    private static final Logger logger = LoggerFactory.getLogger(HazelcastNode.class);

    public static void main(String[] args) {
        try {
            String configFile;
            if (args != null && args.length > 0) {
                configFile = args[0];
            } else {
                configFile = "hazelcast-node.properties";
            }
            String version = VersionGetter.getProjectVersionNumber("bcs-hazelcast-node");
            logger.info("===== Launching Hazelcast cache node =====");
            logger.info("Version : " + version);
            logger.info("Config file : " + configFile);
            PropertiesEx prop = new PropertiesEx(configFile);
            ClusterTopology cluster = new ClusterTopologyImpl(prop, version);
            cluster.createCacheNode();
            logger.info("hazelcast-node is UP and RUNNING");
            scheduleHourlyStatusLogger();
        } catch (Exception e) {
            logger.error("Cannot start Hazelcast cache node ", e);
        }
    }

    /**
     * We log the status of the server every hour to support Shell scripts that scan <b>today's</b> log files
     * to determine if a process is up and running. The most reliable way to determine if a process is up and running
     * is to use its services, but for simple Shell scripts, such complexity is undesired.
     */
    private static void scheduleHourlyStatusLogger() {
        SchedulerUtils.scheduleAtBeginningOfEveryHour(new Runnable() {
            @Override
            public void run() {
                logger.info("hazelcast-node is UP and RUNNING");
            }
        });
    }
}

============
import java.util.Calendar;
import java.util.Date;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

public class SchedulerUtils {

    /**
     * Schedule a task every hour.
     *
     * <p>With Spring 4, this utility method could be replaced with @Scheduled.
     *
     * @param runnable task
     * @return next execution of the task
     */
    public static Date scheduleAtBeginningOfEveryHour(Runnable runnable) {
        final int oneHourInMS = 60 * 60 * 1000;

        final Date now = new Date();
        final Date nextHour = nextHour();
        final long initialDelayInMS = Math.max(nextHour.getTime() - now.getTime(), 0);

        ScheduledExecutorService scheduler = Executors.newSingleThreadScheduledExecutor();
        scheduler.scheduleAtFixedRate(runnable, initialDelayInMS, oneHourInMS, TimeUnit.MILLISECONDS);
        return nextHour;
    }

    /**
     * @return a date corresponding to the next hour at XX:00:00.000
     */
    private static Date nextHour() {
        Calendar calendar = Calendar.getInstance();
        calendar.clear(Calendar.MINUTE);
        calendar.clear(Calendar.SECOND);
        calendar.clear(Calendar.MILLISECOND);
        calendar.add(Calendar.HOUR_OF_DAY, 1);
        return calendar.getTime();
    }

}
